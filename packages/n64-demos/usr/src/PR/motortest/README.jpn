
振動パック・プログラミングマニュアル                          Dec 15th 1997
￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣

１．はじめに

　振動パックの制御として可能なのは、モータを動作させることと、モータを停止さ
せることの２種類です。つまり、モータを制御するのに必要な処理としては、「前準
備」「動かす」「止める」の３種類であり、振動パック関数として、この３種類を用
意しています。


２．基本的な使い方

――コントローラの初期化――

　まず、コントローラについてのイニシャライズを行う必要があります。また、対象
とするコントローラ・ポートにコントローラが差し込まれているか確認する必要があ
ります。これは、通常コントローラを使用するときと同じように、関数osContInit()
や、関数osContStartQuery() & 関数osContGetQueryの呼び出し等で行ってください。

――振動パックの初期化――

　正しくコントローラが接続されていると認識できたとき、そのコントローラポート
に差し込まれている振動パックに対して初期化を行う必要があります。

　この振動パックを初期化するための関数は、osMotorInit()です。

　このとき、振動パックが正しく差し込まれているかどうかを調べるために、関数の
戻り値を確認する必要があります。エラーコードが０のときは、振動パックが正しく
差し込まれています。エラーコードがPFS_ERR_NOPACKのときは、コントローラに何も
差し込まれていません。PFS_ERR_DEVICEのときは、振動パックではないデバイスが
コントローラに差し込まれています。それ以外のエラーが返るときは、コントローラ
か振動パックの接続がおかしいか、そうでなければ、コントローラか振動パックに異
常があると考えられます。

――振動パックのモータの作動・停止――

　振動パックのモータを動かすには、関数osMotorStart()の呼び出しを行います。

　返り値が０の場合は、モータを動かすことに成功しており、問題はありません。
返り値が０ではない値の場合には、PIfとの通信エラーなどの理由で、モータを動か
すことができていません。このときは、再度関数osMotorStart()の呼び出しを行っ
てください。

　動いている振動パックのモータを止めるには、関数osMotorStop()の呼び出しを行
います。返り値については、関数osMotorStart()と同様です。

  注意点としては、振動パック動作中、振動パックとコネクタ間で接触不良になる
可能性があります。こういった場合、正しく動作できたかどうか、ソフト的には判
断ができません。つまり、関数osMotorStart()（あるいは、関数osMotorStop()）
の呼び出しに成功したにもかかわらず、実際には、振動パックが動いてない（止まっ
ていない）場合があります。

  ゲーム中などでは、振動パックが動きっぱなしで止まらないという状況を避け
るため、振動パックを止めるべきところでは、関数osMotorStop()を１fr.程度ごとに
３回連続でコールするようにしてください。

  ポーズ中や、リセットが押された場合には、必ず振動パックを止めなければな
りません。この場合は、osMotorInit()を一度コールしてから、関数osMotorStop()
を１fr.程度ごとに３回連続でコールするようにしてください。理由については、
プログラミング注意事項をご参照ください。なお、このデモサンプルでは、この
ような機能は実装しておりませんので、ユーザ側での対処をお願いします。


３．振動パック関数の説明

NAME
    osMotorInit  - 振動パック関数のイニシャライズ
    osMotorStart - モータの作動
    osMotorStop  - モータの停止

SYNOPSIS
    #include "motor.h"

    s32  osMotorInit(OSMesgQueue *siMessegeQ, OSPfs *pfs, int channel);
    s32  osMotorStart(OSPfs *pfs);
    s32  osMotorStop(OSPfs *pfs);

DESCRIPTION

  osMotorInit()は、振動パックの初期化関数です。SIのメッセージ・キュー、
OSPfs構造体、コントローラのチャンネル番号を引数とします。必ず一番最初に呼ん
でください。
  この関数が返すエラーコードとしては、PFS_ERR_NOPACK、PFS_ERR_CONTRFAIL、
PFS_ERR_DEVICE があります。
　PFS_ERR_NOPACKは、コントローラに何も差し込まれていません。
　PFS_ERR_CONTRFAILは、コントローラとのデータ転送の失敗です。このエラーコー
ドが返ってきた場合、コントローラが正しく接続されていないか、あるいは、コン
トローラコネクタに異常がある可能性があります。
　PFS_ERR_DEVICEは、振動パックではないデバイスがコントローラに挿さっていま
す。

　osMotorStart()は、モータ作動関数です。OSPfs 構造体を引数とします。この関
数の呼び出しを行うことによって、モータが動きます。
  内部的には、コントローラパックに対して単にデータの書き込みを行っているだ
けであり、振動パックのステータスのチェックなどは高速化のために行っていませ
ん。そのため、コントローラや振動パックを抜き差ししてしまった場合には、もう
一度、osMotorInit() の呼び出しを行わないと動作しません。
  エラーコードについてですが、 PFS_ERR_CONTRFAILが返ってきた場合、通信が失
敗しています。つまり、モータを作動させることができていません。通信上のエラー
が発生する可能性が少なからずありますので、正しく動作したかどうかエラーコー
ドで確認する必要があります。

　osMotorStop()は、モータ停止関数です。OSPfs 構造体を引数とします。この関数
を呼ぶことによって、モータが止まります。
  この関数は、内部的には、osMotorStart()と同様の処理を行っています。



４．サンプルプログラムについて

　振動パック・ライプラリのアーカイブには、振動パック動作確認用サンプルプロ
グラムが同梱されています。このサンプルプログラムの操作方法は次の通りです。

　AボタンでモータをON、BボタンでOFF、また、Zトリガーを押すと、3D-STICKの倒
す量に応じて、振動の強さが変わるようになっています。


５．注意事項（Ｑ＆Ａ形式）

Ｑ１）振動する強さを変えたいのですが？

Ａ１）制御としては、モータを回しっぱなしか、止めておくかの２種類しかありま
せん。そのため、適当な強さで振動させるには、アプリケーション・プログラムが
適度な周期でオン・オフを繰り返す必要があります。具体例としては、サンプル・
プログラムを参照してください。

Ｑ２）ゲーム中に振動パックをいったん抜いて、もう一度差し込むと、ちゃんと動
きません。

Ａ２）振動パックを挿し直したりすると、関数osMotorInit()をもう一度呼び出さな
いと、正しく動作しません。ただ、関数osMotorInit()を頻繁に呼び出すと、パフォー
マンスの低下を招きます。
　そのため、「ゲーム途中で振動パックを抜かないでください」等の注意文をゲー
ムソフトの取扱説明書に記載するか、ゲーム画面に表示するなどして、ユーザに対
して注意を促すようにしてください。

Ｑ３）コントローラからの読み込みデータが変になりました。

Ａ３）関数osContStartQuery()と関数osContGetQuery()の間で、振動パック関数の
呼び出しを行っていませんか？　他のスレッドがＳＩのアクセスにいっているとき
に、振動パック関数の呼び出しを行うと動作がおかしくなります。コントローラの
読み込みといっしょに振動パック関数を使用する場合には、何らかの排他処理が必
要となります。

